# 进程间通信

## 修改hostname

`hostnamectl set-hostname yourhostname`

`hostnamectl`查看



## 进程通信

进程通信：在用户空间实现进程通信是**不可能**的，但通过linux内核通信

线程通信：可以在用户空间就可以实现，可以通过全局变量通信



## 通信方式

1. 管道通信： 无名管道，有名管道（文件系统有名）
2. 信号通信：信号（通知）通信包括：信号的发送、信号的接收和信号的处理
3. IPC(inter-Process Communication)通信：共享内存、消息队列和信号灯



### 进程通信课程的学习思路

每一种通信方式都是**基于文件IO的思想**

open:功能： 创建或打开进程通信对象。函数形式不一样，有的是有多个函数完成。

write:功能：向进程通信对象中写入内容。函数形式可能不一样。

read:功能：从进程通信对象中读取内容。函数形式可能不一样。

close:功能：关闭或删除进程通信对象。形式可能不一样。





## 无名管道

 原理图：![无名管道原理图](E:\Embedded\NOTE\linux_node\embedded\linux\stage two\picture\无名管道原理图.PNG)

管道是一个特殊的文件，是由 **队列**来实现的

在文件IO中创建一个文件或打开一个文件是由open函数来实现的， **它不能创建管道文件**，只能用pipe函数来创建管道。

函数形式：`int pipe(int fd[2])`

功能： 创建管道，为系统调用

参数：得到的文件描述符两个。管道有一个读端fd[0]和写端fd[1]。

返回值：成功0，失败-1



example

```c
#include <stdio.h>
#define BUFSIZE 128
int main(void)
{
	int fd[2];
	int ret = 0;
	char write_buf[BUFSIZE] = {"hello linux\n"};
	char read_buf[BUFSIZE] = {0};
	ret = pipe(fd);
	if (ret < 0)
	{
		printf("pipe failure\n");
		return 0;
	}
	
	write(fd[1], write_buf, sizeof(write_buf));

	read(fd[0], read_buf, sizeof(read_buf));
	printf("content is %s", read_buf);	
	close(fd[0]);
	close(fd[1]);
	return 0;
}

```



注意：

1. 管道是创建在内存中的，进程结束，空间释放，管道就不存在了
2. 管道中的东西，读完了就删除了(队列缘故)
3. 如果管道中没有东西可读，则会读堵塞(S+)
4. 内核开辟的管道大小为65536Byte

example：

```c
#include <stdio.h>
#include <sys/types.h>
int main()
{
        pid_t pid;
        int fd[2];
        int ret;
        unsigned char buf = 0;
        ret = pipe(fd);
    	if (ret < 0)
        {
            printf("pipe failure\n");
            return -1;
        }
        pid = fork();
        if (pid == 0)
        {
                read(fd[0], &buf, sizeof(unsigned char));
                while (!buf);
                int i = 0;
                for (; i<5; i++)
                {
                        printf("child process %d\n\n", i);
                        usleep(100);
                }
        }

        if (pid > 0)
        {
                int i = 0;
                for (; i<5; i++)
                {
                        printf("parent process %d\n\n", i);
                        usleep(100);
                }
                buf = 1;
                write(fd[1], &buf, sizeof(unsigned char));
        }
    while(1);
        return 0;
}
```

**缺点** 不能实现 *非*父子进程之间的通信，因为pipe(int fd[])中fd未复制.



## 有名管道

有名：文件系统中存在该文件节点，每一个文件节点都有一个inode号且文件类型为 `p`

1. 创建这个文件节点，不可以通过open函数，open函数只能创建普通节点，不能创建特殊文件（管道-mkfifo，套接字-socket，字符设备文件-mknod， 块设备文件-mknod，符号链接文件-ln -s， 目录文件mkdir）
2. 管道文件 **只有inode号**，不占磁盘空间
   - 与套接字、字符设备文件、块设备文件一样
   - 而 普通文件和符号链接文件和目录文件，不仅有inode号，还占用磁盘块空间。
3. mkfifo 用来创建管道文件的节点，**没有**在内核中创建管道。只有通过open函数 **打开**该文件节点才会在内核空间创建管道。

```c
int mkfifo(const char *filename, mode_t mode);
//功能：创建管道文件(没有生成管道)
//参数：管道文件文件名，权限（和umask有关）
//return： 创建成功0， 失败-1
```



example:

```c
//write side
#include <fcntl.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
//#define PIP
int main()
{
        int ret;
#ifdef PIP
        ret = mkfifo("./mkfifo", 0777);
        if (ret < 0)
        {
                printf("mkfifo falure\n");
                return -1;
        }
        printf("mkfifo new successfully\n");
#endif

        unsigned char buf = 0;
        printf("ready to open mkfifo\n");
        ret = open("./mkfifo", O_WRONLY);
        if (ret < 0)
        {
                printf("open mkfifo falure\n");
                return -1;
        }
        printf("open mkfifo successfully\n");
        sleep(5);
        write(ret, &buf, sizeof(unsigned char));
        printf("mkfifo write over\n");

        while(1);
        return 0;
}

        unsigned char buf = 0;
        printf("ready to open mkfifo\n");
        ret = open("./mkfifo", O_WRONLY);
        if (ret < 0)
        {
                printf("open mkfifo falure\n");
                return -1;
        }
        printf("open mkfifo successfully\n");
        sleep(5);
        write(ret, &buf, sizeof(unsigned char));
        printf("mkfifo write over\n");

        while(1);
        return 0;
}

```



```c
//read side
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
//#define PIP
int main()
{
	int ret;
	unsigned char buf = 0;
	printf("ready to open mkfifo\n");
	ret = open("./mkfifo",O_RDONLY);
	if (ret < 0)
	{
		printf("open mkfifo falure\n");
		return -1;
	}
	printf("open mkfifo successfully\n");
	read(ret, &buf, sizeof(unsigned char));
	if (buf == 1)
	{
		printf("buf one over\n");
	}
	printf("mkfifo read over\n");
	while(1);
	return 0;
}

```





## 信号

信号通信，就是内核向用户空间进程 **发送信号**， 只有 **内核才能发送信号**，用户空间进程不能发送信号



内核可发送的代码：

`kill -l`



信号通信的框架：

1. 信号的发送（发送信号进程）： kill raise alarm
2. 信号的接收（接收信号进程）： pause sleep while(1)
3. 信号的处理（接收信号进程）： signal



### kill

```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
// pid: 正数：接收信号的进程的进程号
//		0: 信号被发送到所有和pid进程在同一个进程组的进程
//		1: 信号发给所有的进程表中的进程（除了进程号最大的进程外）

//return： 成功0， 出错-1；
```



### raise

**发送信号给自己**

等于 `kill(getpid(), sig)`

```c
#include <sys/types.h>
#include <signal.h>

int raise(int sig);
//return : 成功0 出错-1
```

**raise(9) == _exit()而不是exit()**

example:

```c
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
int main()
{
	pid_t pid;
	pid = fork();
	if (pid > 0)
	{
		printf("parent\n");
		sleep(5);
		if (waitpid(pid, NULL, WNOHANG) == 0) //如果子进程未退出
		{
			kill(pid, 9);
		}
		while(1);
	}
	if (pid  == 0)
	{
		printf("raise before\n");
		raise(SIGTSTP);	//ctrl+z
		printf("raise after\n");
		exit(0);
	}
	return 0;
}

//运行时候使用&后台运行
//然后 ps-axj查看
```

#### wait 和 waitpid

- wait



![wait](E:\Embedded\NOTE\linux_node\embedded\linux\stage two\picture\func_wait.PNG)

- waipid

  ![waitpid](E:\Embedded\NOTE\linux_node\embedded\linux\stage two\picture\func_waitpid.PNG)